import { NextRequest, NextResponse } from "next/server";
import fs from "fs";
import path from "path";

/**
 * GET /api/krj/decomposition
 *
 * Returns the enriched signal decomposition data generated by the
 * Python signal_generator.py pipeline. This includes:
 *   - Regime score/confidence/label + market features
 *   - Per-ticker: raw prediction, regime-adjusted prediction,
 *     SHAP decomposition into 4 signal categories
 *
 * Optional query params:
 *   ?tickers=AAPL,MSFT  -- filter to specific tickers
 */
export async function GET(request: NextRequest) {
  try {
    const filePath = path.join(process.cwd(), "data", "krj", "enriched_signals.json");

    if (!fs.existsSync(filePath)) {
      return NextResponse.json(
        { available: false, error: "Enriched signals not yet generated" },
        { status: 200 }
      );
    }

    const raw = fs.readFileSync(filePath, "utf8");
    const data = JSON.parse(raw);

    // Optional ticker filter
    const { searchParams } = new URL(request.url);
    const tickersParam = searchParams.get("tickers");

    if (tickersParam) {
      const wantTickers = new Set(
        tickersParam.split(",").map((t) => t.trim().toUpperCase()).filter(Boolean)
      );
      const filteredTickers: Record<string, unknown> = {};
      for (const [ticker, info] of Object.entries(data.tickers || {})) {
        if (wantTickers.has(ticker.toUpperCase())) {
          filteredTickers[ticker] = info;
        }
      }
      return NextResponse.json({
        available: true,
        signal_date: data.signal_date,
        generated_at: data.generated_at,
        regime: data.regime,
        model_info: data.model_info,
        tickers: filteredTickers,
      });
    }

    return NextResponse.json({
      available: true,
      ...data,
    });
  } catch (e) {
    console.error("Decomposition API error:", e);
    return NextResponse.json(
      { available: false, error: "Failed to load enriched signals" },
      { status: 500 }
    );
  }
}
