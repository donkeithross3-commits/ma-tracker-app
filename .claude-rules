# M&A Tracker Development Rules
# Auto-loaded by Claude Code at session start

## Project Overview
**Name:** M&A Intelligence Tracker
**Stack:** Next.js (frontend) + FastAPI (backend) + PostgreSQL + Background Monitors
**Purpose:** Track and analyze M&A deals with real-time intelligence gathering

---

## Core Development Philosophy

### 1. Fail Early, Fail Often
- Small, testable steps only
- Each change must be independently verifiable
- If a task takes >15 minutes, it's too big - break it down
- Commit-ready code after each atomic task

### 2. Test-First Development
- Write tests BEFORE implementation (when applicable)
- Backend: pytest for Python services
- Frontend: Jest/React Testing Library for Next.js
- Database: Test migrations in dev before applying to production

### 3. Explicit Over Implicit
- Clear error messages
- Fail fast with validation
- Log all important events
- No silent failures

---

## Architecture Patterns

### Dual-Stack Structure
```
/ma-tracker-app
├── /app                    # Next.js 13+ (App Router)
├── /components             # React components
├── /lib                    # Frontend utilities
├── /python-service         # FastAPI backend
│   ├── /app               # FastAPI application
│   ├── /migrations        # SQL migrations (numbered)
│   └── /tests             # Python tests
└── /prisma                # Prisma schema (currently unused)
```

### Background Services (Python)
- **EDGAR Monitor**: Scrapes SEC filings every 60s for M&A activity
- **Intelligence Orchestrator**: Monitors external news sources for deal mentions
- **Halt Monitor**: Scrapes NASDAQ/NYSE for trading halts every 2s
- **Research Worker**: Generates deal research reports using Claude AI
- **Ticker Watch Monitor**: Continuously monitors EDGAR for filings from rumored deal tickers

All monitors can be controlled via API endpoints (see Intelligence Monitoring section below).

### Intelligence Monitoring System

**Active Sources:**
- ✅ GlobeNewswire M&A (polls every 10 min)
- ✅ GlobeNewswire Corporate Actions (polls every 15 min)
- ✅ GlobeNewswire Executive Changes (polls every 30 min)
- ✅ Seeking Alpha M&A
- ✅ FTC Early Termination Notices
- ❌ Reuters M&A (disabled - Cloudflare blocking)

**How It Works:**
1. Monitors scrape external sources for M&A mentions
2. Rule-based detector identifies potential deals (keywords, NER, confidence scoring)
3. Creates "staged deals" in database (status: pending)
4. User reviews staged deals at `/staging` page
5. Approved deals become active in `deal_intelligence` table
6. System cross-references with EDGAR filings
7. Ticker watch monitor tracks ongoing EDGAR activity for rumored deals

**Starting/Stopping:**
```bash
# Start intelligence monitoring
curl -X POST http://localhost:8000/intelligence/monitoring/start

# Stop intelligence monitoring
curl -X POST http://localhost:8000/intelligence/monitoring/stop

# Check status
curl http://localhost:8000/intelligence/monitoring/status
```

**Key Pages:**
- `/staging` - Review scanned articles and staged deals
- `/intelligence/deals` - View active intelligence deals
- `/rumored-deals` - Watch list of rumored/unconfirmed deals

---

## Database Standards

### Migration Workflow
1. Create numbered migration: `migrations/XXX_description.sql`
2. Follow existing pattern (see 001-010 for examples)
3. Test migration locally with asyncpg:
   ```python
   conn = await asyncpg.connect(DATABASE_URL)
   await conn.execute(sql)
   ```
4. Never modify old migrations - create new ones
5. Use transactions for complex migrations

### Table Naming
- Snake_case: `deal_intelligence`, `staged_deals`, `halt_events`
- Use descriptive names, avoid abbreviations
- Foreign keys: `{table}_id` (e.g., `deal_id`)

### Key Tables
- `deal_intelligence`: Core M&A deals table
- `staged_deals`: Deals pending approval
- `deal_sources`: News sources for each deal
- `edgar_filings`: SEC filing tracker
- `halt_events`: Trading halt history
- `alert_notifications`: System alerts
- `source_monitors`: Configuration for external sources

---

## Python Service (FastAPI) Standards

### Code Style
- PEP 8 compliance
- Type hints required: `def func(x: int) -> str:`
- Docstrings for classes and complex functions
- Use `async/await` for I/O operations

### API Patterns
```python
# Route structure
@router.get("/resource/{id}")
async def get_resource(id: str) -> ResourceResponse:
    """Get resource by ID"""
    try:
        # Validate input
        # Fetch from database
        # Return response
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

### Error Handling
- Use HTTPException for client errors (400s)
- Log unexpected errors with `exc_info=True`
- Return structured error responses
- Never expose internal implementation details in errors

### Adding New Monitors
1. Create class in `/app/monitors/{name}_monitor.py`
2. Implement `start()` and `stop()` methods
3. Add to `app/main.py` startup/shutdown events
4. Use `asyncio.create_task()` for background execution
5. Add API routes in `/app/api/{name}_routes.py`

---

## Frontend (Next.js) Standards

### File Structure
- App Router (Next.js 13+)
- Server Components by default
- Use `'use client'` only when needed (state, effects, browser APIs)

### Component Patterns
```typescript
// Prefer server components
export default async function Page() {
  const data = await fetchData()
  return <div>{data}</div>
}

// Client components when needed
'use client'
export default function InteractiveComponent() {
  const [state, setState] = useState()
  return <div onClick={() => setState(...)}/>
}
```

### API Integration
- Use `fetch()` in Server Components
- Use React Query/SWR for Client Components
- API base URL: `http://localhost:8000` (dev)

---

## Git & Commit Standards

### Commit Messages
Follow Conventional Commits:
```
feat: Add halt monitoring system
fix: Correct deal deduplication logic
docs: Update API documentation
refactor: Simplify EDGAR parsing logic
test: Add tests for deal approval flow
```

### Branching
- `main`: Production-ready code
- Feature branches: `feature/halt-monitoring`
- Bug fixes: `fix/edgar-timeout`
- Keep branches short-lived

### Before Committing
1. Run tests (if applicable)
2. Check `git diff` for unintended changes
3. Verify services still start correctly
4. Use atomic commits (one logical change)

---

## Development → Staging Workflow

### Platform-Specific Deployment

**macOS/Linux:**
```bash
./deploy-staging.sh      # Use this on Mac/Unix systems
```

**Windows:**
```bash
deploy-staging.bat       # Use this on Windows systems
```

### What the Deploy Script Does
1. **Stops all services** (dev-stop.sh/bat)
2. **Pulls latest code** from `origin/main` via `git reset --hard`
3. **Cleans Python cache** (removes __pycache__ and .pyc files)
4. **Cleans Next.js cache** (removes .next directory) ← CRITICAL for UI updates!
5. **Cleans logs** (removes old log files)
6. **Starts all services** (dev-start.sh/bat)
7. **Auto-starts intelligence monitoring** via API call

### Important: Next.js Cache Clearing

**Problem**: Next.js caches compiled pages in `.next/`. If this isn't cleared after pulling code, UI changes won't appear.

**Solution**: Always delete `.next/` before restarting Next.js:
```bash
rm -rf .next && npm run dev
```

The deploy scripts now handle this automatically.

### Manual Cache Clear (if needed)
```bash
# If changes don't appear after deployment:
rm -rf .next           # Clear Next.js cache
rm -rf python-service/__pycache__  # Clear Python cache
```

---

## Service Management

### Starting Services

**Quick Start (Recommended):**
```bash
./dev-start.sh           # Mac/Linux
dev-start.bat            # Windows
```

**Manual Start:**
```bash
# Frontend (from /ma-tracker-app)
npm run dev              # Port 3000

# Backend (from /ma-tracker-app/python-service)
/Users/donaldross/opt/anaconda3/bin/python3 start_server.py  # Port 8000
```

**Note**: Always use the absolute Python path (`/Users/donaldross/opt/anaconda3/bin/python3`) to ensure correct environment.

### Stopping Services
```bash
./dev-stop.sh            # Mac/Linux
dev-stop.bat             # Windows
```

### Health Checks
- Frontend: http://localhost:3000
- Backend: http://localhost:8000/health
- Staging page: http://localhost:3000/staging
- Monitors: Check `/edgar/status`, `/halts/status`, `/intelligence/monitoring/status`

### Database
- PostgreSQL (Neon hosted - cloud database)
- Connection string in `.env` (never commit!)
- Use asyncpg for Python connections
- Database migrations: Numbered SQL files in `python-service/migrations/`

---

## Common Patterns

### Adding a New Deal Source
1. Add source to `source_monitors` table
2. Create monitor class extending base pattern
3. Implement scraping logic
4. Parse into `StagedDeal` format
5. Add API endpoints for manual triggering
6. Add to orchestrator startup

### Adding API Endpoint
1. Create route in appropriate `/app/api/` file
2. Add Pydantic models for request/response
3. Include in router and register in `main.py`
4. Add error handling
5. Test with curl/Postman
6. Document in API docs (future)

### Database Schema Changes
1. Create new migration file (next number)
2. Include both forward and (if possible) rollback logic
3. Test on dev database
4. Apply to production via Python script
5. Update any affected code
6. Commit migration + code changes together

---

## Never Do

- ❌ Modify existing migrations
- ❌ Commit `.env` files or secrets
- ❌ Mix refactoring with feature changes
- ❌ Break existing API contracts without versioning
- ❌ Delete tests
- ❌ Make database changes without migrations
- ❌ Deploy without testing migrations first
- ❌ Use `SELECT *` in production queries
- ❌ Store passwords in plain text
- ❌ Ignore TypeScript/Python errors

---

## Always Do

- ✅ Write descriptive commit messages
- ✅ Use type hints/annotations
- ✅ Handle errors explicitly
- ✅ Log important operations
- ✅ Validate user input
- ✅ Use transactions for multi-table updates
- ✅ Test migrations before applying
- ✅ Follow existing code patterns
- ✅ Ask when uncertain
- ✅ Keep functions small and focused

---

## When Uncertain

1. Check existing code for patterns
2. Review recent commits: `git log --oneline -10`
3. Ask before making architectural changes
4. Write a test to explore behavior
5. Start with smallest possible change

---

## Emergency Procedures

### If Service Won't Start
1. Check logs for error messages
2. Verify DATABASE_URL is set
3. Check port conflicts: `lsof -i :8000`
4. Try restarting services
5. Check recent git changes

### If Database Migration Fails
1. **DO NOT** manually edit production database
2. Check migration SQL syntax
3. Test migration on dev database copy
4. Create rollback migration if needed
5. Document the issue

### If Monitor Stops Working
1. Check service status endpoint
2. Review logs for errors
3. Verify external service availability
4. Check database connections
5. Restart Python service if needed

---

## Testing Philosophy

### Python Tests
```python
# tests/test_feature.py
import pytest

def test_feature():
    # Arrange
    input_data = {...}

    # Act
    result = function(input_data)

    # Assert
    assert result == expected
```

### Integration Tests
- Test full request/response cycle
- Use test database
- Clean up after tests
- Mock external API calls

---

## Performance Guidelines

- Use database indexes for frequently queried fields
- Batch database operations when possible
- Cache expensive computations
- Use async for I/O-bound operations
- Monitor for N+1 query problems
- Keep API response times <500ms

---

*Last updated: 2025-01-09*
*For questions or clarifications, check git history or ask*
