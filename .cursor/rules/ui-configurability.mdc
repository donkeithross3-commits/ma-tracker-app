---
description: UI configurability architecture — column chooser, comfort mode, preferences context
alwaysApply: true
---

> Shared agent contract: [docs/agent/AGENTS.md](docs/agent/AGENTS.md)

# UI Configurability Architecture

## Philosophy

Two users with opposite needs use the same dashboard:
- **Compact / Power User**: wants maximum data density, many columns visible, small padding.
  This is the default mode. KRJ signals page is the reference implementation.
- **Comfort / Accessible User**: has Parkinson's, needs larger touch targets (44px min),
  bigger text, more padding. IBPositionsTab (trade buttons, position boxes) is the reference.

Each screen has a **native density** — it was originally designed for one user type.
The Comfort Mode toggle provides an optimized alternate view, not a uniform scale.

Key design rules:
- **Never auto-hide columns.** If content overflows, shrink font/padding fluidly. The user
  decides which columns to remove via the Column Chooser.
- **Comfort mode must scale intelligently** with screen width and visible column count.
  Fixed breakpoints break on external monitors / varying column selections.
- **Keep the system lightweight.** One JSONB column, one React context, one CSS density layer.
  No per-table persistence endpoints, no database migrations for new tables.

## System Components

### 1. Database Layer

Single JSONB column on `user_preferences`:
```sql
ALTER TABLE user_preferences ADD COLUMN ui_prefs JSONB DEFAULT '{}';
```

Schema in `prisma/schema.prisma`:
```prisma
uiPrefs Json? @map("ui_prefs")
```

Shape of `uiPrefs`:
```typescript
interface UIPrefs {
  densityMode?: "compact" | "comfort" | null   // null = compact (default)
  columnVisibility?: {
    [tableKey: string]: string[]  // ordered array of visible column keys
  }
}
```

Adding a new table's columns requires NO migration — just use a new key in `columnVisibility`.

### 2. API Layer

`/api/user/preferences` (GET / PUT) — existing endpoint extended with `uiPrefs` field.
All preference categories (maOptionsPrefs, dealListPrefs, uiPrefs, customTickers) are
fetched in one call and persisted atomically via upsert.

### 3. React Context — `UIPreferencesProvider`

**File:** `lib/ui-preferences.tsx`

Wraps the app in `app/layout.tsx` inside `<SessionProvider>`. Provides:
- `prefs` / `loaded` — full preferences object and loading state
- `isComfort` / `toggleDensity()` — density mode state and toggle
- `getVisibleColumns(pageKey)` — returns `string[] | null` (null = use defaults)
- `setVisibleColumns(pageKey, columns)` — persists column selection
- `updatePrefs(partial)` — generic deep-merge for any preference category

**Persistence strategy:**
- All updates are debounced (600ms) to avoid chatty API calls
- On unmount / navigation, `sendBeacon` flushes any pending save
- Single source of truth — eliminates read-modify-write race conditions

**Density attribute:**
- Sets `data-density="comfort"` on `<html>` immediately on state change
- CSS custom properties in `globals.css` respond to this attribute

### 4. CSS Density System

**File:** `app/globals.css`

Two tiers of CSS custom properties:
```
:root                        → compact defaults (KRJ-calibrated)
[data-density="comfort"]     → comfort overrides (IB Positions-calibrated)
```

Variables: `--d-table-py`, `--d-table-px`, `--d-table-font`, `--d-header-font`,
`--d-row-min-h`, `--d-btn-*`, `--d-action-btn-*`, `--d-section-gap`, `--d-card-*`

**Fluid table scaling (comfort mode only):**
```css
.d-table-wrap { container-type: inline-size; }

[data-density="comfort"] .d-table th,
[data-density="comfort"] .d-table td {
  font-size: clamp(0.875rem, calc(100cqi / var(--visible-cols, 15) / 6), 1.375rem);
  /* similar clamp() for padding */
}
```

Tables opt in by:
1. Wrapping in `<div className="d-table-wrap" style={{ "--visible-cols": N }}>`
2. Adding `className="d-table"` to the `<table>`

The `--visible-cols` CSS variable is set by React from the length of the visible columns
array, enabling font/padding to scale proportionally as columns are added/removed.

**Global interactive element scaling (comfort mode):**

In addition to tables, comfort mode automatically scales ALL interactive elements
across the app using broad CSS selectors based on element types and ARIA roles:

| Selector | Compact | Comfort |
|----------|---------|---------|
| `button` | native | 44px min-height, larger font |
| `button > svg` | h-3.5 to h-4 | 20px (1.25rem) !important |
| `input`, `textarea`, `select` | native | 44px min-height, 1rem font |
| `[role="checkbox"]` | 16px (h-4 w-4) | 24px (1.5rem) !important |
| `[role="menuitem"]` etc. | native | 44px rows, 1rem font |
| `[role="tab"]` | native | 44px, 1.125rem, 0.625rem padding |
| `[role="dialog"]` | p-6 | 1.5rem padding, 1.375rem titles |
| `.cursor-grab > svg` | h-4 w-4 | 24px (1.5rem) !important |
| `.divide-y > div/li` | native | 44px min-height, flex center |
| `.text-xs` | 0.75rem | promoted to 0.875rem !important |

These rules live in `@layer components` so they have correct specificity. Elements
inside `.d-table` are excluded to avoid double-scaling with the fluid table system.

**Escape hatches:**
- `.no-density` class on any element opts it out of all comfort scaling
- `.inline-edit` class on inputs opts them out of comfort min-height/font scaling.
  Use on compact inline editing inputs (e.g. order qty/price fields in tables).
  Unlike `.no-density` which suppresses ALL comfort rules, `.inline-edit` targets
  only the input sizing rules that break tight inline layouts.
- `.d-table input` elements are automatically excluded via a CSS override rule
  (higher specificity beats the global input rule). This works reliably across
  browsers, unlike the previous `:not(.d-table input)` complex selector in `:not()`.

### 5. ColumnChooser Component

**File:** `components/ui/ColumnChooser.tsx`

Fully generic, reusable Radix dropdown with checkboxes. Props:
- `columns: ColumnDef[]` — all available columns (key + label)
- `visible: string[]` — currently visible keys (order-preserved)
- `defaults: string[]` — default set (used by "Reset to defaults" action)
- `onChange: (keys: string[]) => void` — callback when visibility changes
- `locked?: string[]` — columns that cannot be hidden (greyed out checkbox)
- `size?: "sm" | "md"` — button size variant

Behavior:
- Toggling a column inserts it at its position in the master column order
- Cannot hide all columns (at least 1 must remain)
- "Reset to defaults" button appears only when current differs from defaults
- Menu stays open on toggle (onSelect preventDefault)

### 6. Comfort Mode Toggle

**File:** `components/UserMenu.tsx`

A switch in the user menu dropdown. Uses `useUIPreferences()` for `isComfort` and
`toggleDensity`. Available on every page since UserMenu is in the global header.

## Adding Column Chooser to a New Table — Step by Step

```typescript
// 1. Import
import { ColumnChooser, type ColumnDef } from "@/components/ui/ColumnChooser";
import { useUIPreferences } from "@/lib/ui-preferences";

// 2. Define columns outside the component (module-level constants)
const MY_COLUMNS: ColumnDef[] = [
  { key: "ticker", label: "Ticker" },
  { key: "price", label: "Price" },
  { key: "volume", label: "Volume" },
  // ...
];
const MY_DEFAULTS = MY_COLUMNS.map(c => c.key);  // or a subset
const MY_LOCKED = ["ticker"];  // can't be hidden

// 3. Inside the component
const { getVisibleColumns, setVisibleColumns } = useUIPreferences();
const savedCols = getVisibleColumns("myTableKey");
const visibleKeys = useMemo(() => savedCols ?? MY_DEFAULTS, [savedCols]);
const visibleSet = useMemo(() => new Set(visibleKeys), [visibleKeys]);
const handleColsChange = useCallback(
  (keys: string[]) => setVisibleColumns("myTableKey", keys),
  [setVisibleColumns]
);

// 4. Render the chooser (typically in a header/toolbar area)
<ColumnChooser
  columns={MY_COLUMNS}
  visible={visibleKeys}
  defaults={MY_DEFAULTS}
  onChange={handleColsChange}
  locked={MY_LOCKED}
/>

// 5. Wrap the table for comfort-mode fluid scaling
<div className="overflow-x-auto d-table-wrap"
     style={{ "--visible-cols": visibleKeys.length } as React.CSSProperties}>
  <table className="w-full text-sm d-table">
    <thead>
      <tr>
        {visibleSet.has("ticker") && <th>Ticker</th>}
        {visibleSet.has("price") && <th>Price</th>}
        {/* ... */}
      </tr>
    </thead>
    <tbody>
      {rows.map(row => (
        <tr key={row.id}>
          {visibleSet.has("ticker") && <td>{row.ticker}</td>}
          {visibleSet.has("price") && <td>{row.price}</td>}
          {/* ... */}
        </tr>
      ))}
    </tbody>
  </table>
</div>
```

## Tables with Column Choosers (current inventory)

| Table Key            | Component                        | Page/Tab           | Locked Columns       |
|----------------------|----------------------------------|--------------------|----------------------|
| `krj`                | KrjTabsClient                    | /krj               | ticker               |
| `watchedSpreads`     | WatchedSpreadsTable              | M&A Options Monitor| ticker               |
| `candidateStrategies`| CandidateStrategiesTable         | M&A Options Curator| ticker               |
| `optionChain`        | OptionChainViewer                | M&A Options Curator| strike               |
| `dealSelector`       | ScannerDealSelector              | M&A Options Curator| ticker, actions      |
| `ibPositions`        | IBPositionsTab (positions)       | M&A Options Account| symbol, trade        |
| `ibOrders`           | IBPositionsTab (working orders)  | M&A Options Account| symbol, action       |

## Strategy Sub-Columns (Shared)

`StrategyColumns.tsx` exports shared header/cell components used by both
WatchedSpreadsTable and CandidateStrategiesTable. These accept an optional
`visibleCols?: Set<string>` prop. When undefined, all columns render
(backward-compatible). The strategy column keys are:
`strikes`, `legPrices`, `market`, `midEntry`, `farEntry`

The `midEntry` and `farEntry` groups are treated as atomic units — each controls
3 sub-columns (Cost, Profit, IRR) together. The `colSpan` for their grouped
header row dynamically counts visible sub-columns.

## Print Layout Integration

`KrjPrintLayout` accepts `visibleColumns` and only renders columns the user has
selected. Column abbreviations and formatting are handled within the print layout
to keep printed output readable at any column count.

When adding print support to other tables, follow the same pattern: pass the
visible column set to the print component and filter accordingly.

## Components with Targeted Comfort Mode Logic

These components have specific `isComfort` branching beyond what the global CSS provides:

- **TickerEditorModal** (`components/krj/TickerEditorModal.tsx`): Uses `isComfort` from
  `useUIPreferences()` to switch up/down arrow buttons from stacked vertical (`flex-col`)
  to horizontal (`flex-row`) layout, increase icon sizes, add padding/hover backgrounds,
  enlarge drag handles, and scale autocomplete suggestion row padding. The `.no-density`
  class is used on the arrow/delete buttons to prevent the global CSS from adding
  `min-height: 44px` (which would distort the stacked layout in compact mode).

- **Trade Ticket** (`components/ma-options/IBPositionsTab.tsx`): Already designed with
  44px+ touch targets from the start (min-h-[52px] to min-h-[72px], text-xl to text-4xl).
  No comfort mode branching needed — it's inherently accessible.

## Gotchas and Lessons Learned

1. **The `ColumnChooser` is a named export**, not a default export.
   Use: `import { ColumnChooser, type ColumnDef } from "@/components/ui/ColumnChooser"`

2. **Always define column constants at module level**, not inside the component.
   This avoids re-creating arrays on every render and prevents infinite loops with
   `useMemo` dependencies.

3. **`colSpan` in grouped headers must be dynamic.** If a table has grouped headers
   (e.g. "Midpoint Entry" spanning Cost/Profit/IRR), compute colSpan by counting
   how many sub-columns are visible: `colSpan={["cost","profit","irr"].filter(k => visibleSet.has(k)).length}`

4. **Footer/totals `colSpan` must also be dynamic.** If the first N columns are
   spanned with "Totals", count how many of those are actually visible.

5. **Comfort mode CSS only activates on opted-in tables** — those with `d-table-wrap`
   and `d-table` classes. This means existing tables that haven't been converted yet
   are unaffected by the density toggle.

6. **Don't fight the fluid scaling.** In comfort mode, `clamp()` handles font sizing.
   Don't add fixed `text-xs` or `text-sm` classes to cells inside a `d-table` — they
   override the fluid values. Use them only in compact mode or on non-table elements.

7. **The global comfort CSS uses `!important` on SVG sizes and checkboxes.** This is
   necessary because Tailwind utility classes (`h-3.5`, `w-4`) have single-class
   specificity that beats `[data-density="comfort"] button > svg`. If a component needs
   to override, use the `.no-density` escape hatch and manage sizing with `isComfort`.

8. **Elements inside `.d-table` are excluded from global scaling.** The fluid table
   system handles its own font/padding via container queries. Adding global button/input
   scaling inside tables would cause double-scaling. If a table needs larger controls
   (like in-cell edit inputs), handle it with component-level `isComfort` checks.

9. **Position box persistence uses `updatePrefs` directly**, not `setVisibleColumns`.
   The IBPositionsTab's selected ticker boxes are stored in `maOptionsPrefs.selectedTickers`,
   not in `columnVisibility`. The column chooser is a separate concern from position
   box selection.

10. **Prefer global CSS over per-component comfort logic.** The broad CSS selectors in
    `globals.css` handle ~90% of interactive elements automatically. Only add `isComfort`
    branching in a component if the global CSS causes layout breakage (e.g., stacked
    icon buttons that need a layout change, not just a size change). This keeps the
    codebase lightweight and prevents comfort-mode boilerplate from spreading.

11. **Use `.no-density` with `isComfort` together.** When a component needs custom
    comfort logic, add `.no-density` to the element to suppress the global CSS rules,
    then use `isComfort` to apply the right classes. Example: the TickerEditorModal
    arrow buttons use `.no-density` to prevent 44px min-height (which breaks the
    stacked layout), then conditionally apply `p-1.5 rounded hover:bg-gray-700` and
    larger icon sizes when `isComfort` is true.

12. **ARIA roles power the global selectors.** The comfort CSS targets `[role="tab"]`,
    `[role="checkbox"]`, `[role="menuitem"]`, `[role="dialog"]`, etc. Components using
    Radix UI primitives get these roles automatically. Custom components that don't use
    Radix may need explicit `role` attributes to benefit from global scaling.

13. **The trade ticket was designed accessible-first.** Unlike other screens where compact
    is the default, the IBPositionsTab trade ticket uses 52–72px buttons and text-xl to
    text-4xl fonts. This is the gold standard for what comfort mode should feel like.
    When designing new interactive overlays (order entry, risk dialogs), use the trade
    ticket sizing as the reference, not the compact KRJ table sizing.
